					1 - Создание Ubuntu EC2-Instance. 
Поскольку Jenkins написан на Java, то необходимо установить все зависимости (Jenkins требует, чтобы версия Джавы была 8
и выше - написано в требованиях на сайте). Также, чтобы сэкономить время и не ждать окончание выполнения того или иного
скачивания пакетов, был написан элементарный bash-скрипт, который сначала обновляет существующие пакеты, устанавливает
джаву = openjdk-8-jre, а затем, ссылаясь на документацию по установке Jenkins, добавляет ключ, снова обновляет пакеты и
устанавливает сам Дженкинс.
Пока скрипт выполнялся, был создан новый пользователь в AWS, который имеет полный доступ к сервису Elastic Beanstalk.
Его credenrials абсолютно неправильно хранить в открытом виде, но я скопировал так для простоты и быстродействия. 
Наилучшим решением является передавать секреты юзера через export при работе, допустим, с Terraform.
  
					2 - Создание дефолтного веб-приложения от AWS, написаного на Python. 
Elastic Beantalk в качестве конечной точки был выбран неспроста: данный сервис, при правильной (кастомной) конфигурации,
создаст балансировщик загрузки, необходимое количество серверов, задаст правило обновления продукта на серверах. 
В данном примере были созданы 2-3 сервера ЕС-2 (зависит от нагрузки), обновление будет один за одним (то есть, сначала 
один сервер обновляется, затем второй, третий). Данный подход является желательным, так как будет минимальный даунтайм. 
Можно реализовать и другие функции, но для наглядности подойдут и эти.

					3 - Активация Jenkins
Дженкинс работает на 8080 порту (после желательно поменять порт на любой другой доступный в целях безопасности), 
после была попытка подключиться к серверу. Вышла ошибка, которая заключалась в том, что на нашем сервере не открыт 
8080 порт. Решение - создать новую группу безопасности или приаттачить существующую (подходящую). 
В веб-интерфейсе создается учетная запись администратора. В целях без-ти желательно установить надежный пароль 
(система 3/4 и т.д.) и назвать администратора не admin :)
Лучшая настройка - настройка собственными руками. Так что я не устанавливал все рекомендованные плагины, а лишь те, 
которые необходимы для конкретной задачи. Это - Git Plugin and Elastic Beanstalk Plugin.

					4 - Создание и инициализирование репозитория GitHub
Когда разработчики пишут код, они добавляют проект на отдельную ветку, тестируют его и т.д. Предположим, что все 
тесты пройдены, код готов задеплоиться в пре-прод. Я создал новый репозиторий, инициализировал его, закинул в папку 
необходимые файлы проекта и запушил его на ветку мастер. Согласен, что могут (и должны) быть промежуточные действия, 
но для примера код сразу попадает в мастер бранч. 

					5 - Настройка ключей
Чтобы Дженкинс и гит могли коннектиться и взаимодействовать друг с другом, необходимо было сначала создать пару 
ключей (ssh-keygen), а затем отправить приватный ключ на гит, а публичный в Дженкинс.

					6 - Создание job 
Было настроено, что чтобы не засорять мой Дженкинс сервер, хранить только последние 7 джобов. Остальные - удаляются. 
Затем было установлено, что данный проект находится в ГитХаб репозитории, выданы креденшлы и установлен WebHook, чтобы 
Jenkins получал информацию из репозитория немедленно после каких-либо изменений (сначала забыл закрыть ссылку 
"ip:8080/github-webhook/" (из-за чего и была ошибка 302), но затем пофиксил в конце видео). 
Затем, благодаря плагину Elastic Beanstalk, было определено, что наш проект коммуникацирует с Амазоном, были определены 
access & secret keys моего пользователя, которого создал в самом начале. Был установлен регион (так как я с Украины, был 
выбран регион Франкфурта (для быстродействия)), установлены имя приложения и имя окружающей среды приложения. 
И для красоты был установлен формат версии так, чтобы в конце он выводил номер текущей сборки джоба. 

					7 - Деплой приложения из GitHub в AWS
После того, как джоб настроен, я его запустил. И буквально через несколько секунд окружение в AWS начало меняться, то есть, 
весь цикл заработал так, как и планировалось. После вывода на экран новых изменений, я изменил еще раз исходный код проекта. 
Через несколько минут приложение поменялось, установилось версия проекта (номер сборки) - 2.

На этом пока всё. 

Прекрасно понимаю, что данные вещи должны делаться не руками, а через пейплайн и терраформ-манифесты. 
Планирую реализовать это все через код и продемонстрировать в ближайшее время. 

Ссылка на видео:
https://youtu.be/l3cAH5ZFzWs
